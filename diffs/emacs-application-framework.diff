diff --git a/core/buffer.py b/core/buffer.py
index ba34d87..526c87f 100755
--- a/core/buffer.py
+++ b/core/buffer.py
@@ -292,7 +292,7 @@ class Buffer(QGraphicsScene):
     def start_search_input_monitor_thread(self, callback_tag):
         self.fetch_search_input_thread = FetchSearchInputThread(callback_tag)
         self.fetch_search_input_thread.search_changed.connect(self.handle_input_response)
-        self.fetch_search_input_thread.search_finish.connect(self.handle_search_finish)
+        # self.fetch_search_input_thread.search_finish.connect(self.handle_search_finish)
         self.fetch_search_input_thread.start()
 
     def stop_search_input_monitor_thread(self):
@@ -489,6 +489,10 @@ class FetchMarkerInputThread(QThread):
                 
                 marker_input_quit = minibuffer_input and len(minibuffer_input) > 0 and minibuffer_input[-1] in self.marker_quit_keys
                 marker_input_finish = minibuffer_input in self.markers
+                if self.markers is not None:
+                    marker_input_finish = minibuffer_input in self.markers
+                else:
+                    marker_input_finish = False
                 
                 if marker_input_quit:
                     self.running_flag = False
diff --git a/core/webengine.py b/core/webengine.py
index 0ddd00c..e6610c8 100755
--- a/core/webengine.py
+++ b/core/webengine.py
@@ -38,6 +38,7 @@ import base64
 import os
 import platform
 import pathlib
+import subprocess
 
 MOUSE_LEFT_BUTTON = 1
 MOUSE_WHEEL_BUTTON = 4
@@ -867,6 +868,7 @@ class BrowserBuffer(Buffer):
             self.settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, self.enable_javascript)
             self.settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptCanAccessClipboard, self.enable_javascript_access_clipboard)
             self.settings.setAttribute(QWebEngineSettings.WebAttribute.ShowScrollBars, self.enable_scrollbar)
+            self.settings.setAttribute(QWebEngineSettings.WebAttribute.PdfViewerEnabled, False)
 
             if self.unknown_url_scheme_policy == "DisallowUnknownUrlSchemes":
                 self.settings.setUnknownUrlSchemePolicy(self.settings.UnknownUrlSchemePolicy.DisallowUnknownUrlSchemes)
@@ -974,6 +976,44 @@ class BrowserBuffer(Buffer):
                 f.write(base64.b64decode(b64bytes))
 
             message_to_emacs("Save image: " + image_path)
+        elif download_data.endswith(".pdf"):
+            def download_pdf_and_open(download_data):
+                file_name = download_data.split('/')[-1]
+                arxiv_paper_root = '/Users/royokong/arxiv_papers/'
+                if os.path.exists(arxiv_paper_root+file_name):
+                    message_to_emacs("Opening: " + arxiv_paper_root+file_name)
+                    eval_in_emacs('find-file', [arxiv_paper_root+file_name])
+                    return
+
+                paper_root = '/Users/royokong/papers/'
+                if not os.path.exists(paper_root+file_name):
+                    message_to_emacs("Downloading: " + download_data + " to pdf")
+                    command = ['wget',
+                            '-U',
+                            '\'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15\'',
+                            download_data,
+                            '-O',
+                            '/tmp/downloading_pdf']
+                    p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+                    import time
+                    while True:
+                        time.sleep(1)
+                        if p.stdout:
+                            out = p.stdout.readline().decode('utf-8')
+                            out = out.replace('\n', '')
+                            if len(out):
+                                message_to_emacs(out)
+                        poll = p.poll()
+                        if poll is not None:
+                            break
+
+                    os.system('mv /tmp/downloading_pdf '+paper_root+file_name)
+
+                message_to_emacs("Opening: " + paper_root+file_name)
+                eval_in_emacs('find-file', [paper_root+file_name])
+            import threading
+            thread = threading.Thread(target=download_pdf_and_open, args=(download_data,))
+            thread.start()
         else:
             if hasattr(self, "try_start_aria2_daemon"):
                 self.try_start_aria2_daemon()
@@ -1115,11 +1155,11 @@ class BrowserBuffer(Buffer):
         elif callback_tag == "search_text_forward" or callback_tag == "search_text_backward":
             self.buffer_widget.clean_search_and_select()
 
-    def handle_search_forward(self, callback_tag):
+    def handle_search_forward(self, callback_tag="search_text_forward"):
         if callback_tag == "search_text_forward" or callback_tag == "search_text_backward":
             self.buffer_widget._search_text(self.buffer_widget.search_term)
 
-    def handle_search_backward(self, callback_tag):
+    def handle_search_backward(self, callback_tag="search_text_backward"):
         if callback_tag == "search_text_forward" or callback_tag == "search_text_backward":
             self.buffer_widget._search_text(self.buffer_widget.search_term, True)
 
